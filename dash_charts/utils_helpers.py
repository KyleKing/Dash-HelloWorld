"""Helpers for building Dash applications."""

import argparse
import time
from pathlib import Path

import snoop

from .utils_data import TIME_FORMAT_FILE, format_unix

# ----------------------------------------------------------------------------------------------------------------------
# General Debug


def debug_time(message, last=None):
    """Debug timing issues.

    Args:
        message: string message to print
        last: last timestamp

    Returns:
        timestamp: the current timestamp to calculate the next delta

    """
    if last is None:
        last = time.time()
    now = time.time()
    delta = now - last
    if delta > 0.5:
        print(message, delta)  # noqa: T001
    return now


# ----------------------------------------------------------------------------------------------------------------------
# Snoop Logging Module


def snoop_line_col(event):
    """Add line number to snoop output.

    Args:
        event: `snoop.formatting.Event` object

    Returns:
        int: line number

    """
    return event.line_no


class Snooper:
    """Snoop logging instance with helper methods."""

    snoop_path = Path(__file__).parent.resolve() / f'snoop-{format_unix(time.time(), TIME_FORMAT_FILE)}.log'
    """Path to the snoop log file. Defaults to within the .venv/package."""

    snooper = None
    """Snoop instance for static log file output. Initialized in `__init__`."""

    def __init__(self, log_dir=None):
        """Initialize the snoop logger with an optional path if desired.

        Args:
            log_dir: optional path to the log directory. Default is None to fallback to the .venv/package folder

        """
        if log_dir is not None:
            self.snoop_path = log_dir.resolve() / self.snoop_path.name
        self.snooper = snoop.Config(columns=['time', 'file', snoop_line_col], out=self.snoop_path, overwrite=True)

    def clear_snoop_logs(self):
        """Remove all log files generated by snoop."""
        for log_path in self.snoop_path.parent.glob(f'snoop-*{self.snoop_path.suffix}'):
            log_path.unlink()


# ----------------------------------------------------------------------------------------------------------------------
# Dash Helpers


def parse_dash_cli_args():  # pragma: no cover
    """Configure the CLI options for Dash applications.

    Returns:
        dict: keyword arguments for Dash

    """
    parser = argparse.ArgumentParser(description='Process Dash Parameters.')
    parser.add_argument('--port', type=int, default=8050,
                        help='Pass port number to Dash server. Default is 8050')
    parser.add_argument('--nodebug', action='store_true', default=False,
                        help='If set, will disable debug mode. Default is to set `debug=True`')
    args = parser.parse_args()
    return {'port': args.port, 'debug': not args.nodebug}


# ----------------------------------------------------------------------------------------------------------------------
# Functional Programming


def graph_return(resp, keys):
    """Based on concepts of GraphQL, return specified subset of response.

    Args:
        resp: dictionary with values from function
        keys: list of keynames from the resp dictionary

    Returns:
        the `resp` dictionary with only the keys specified in the `keys` list

    Raises:
        RuntimeError: if `keys` is not a list or tuple

    """
    if not (len(keys) and isinstance(keys, (list, tuple))):
        raise RuntimeError(f'Expected list of keys for: `{resp.items()}`, but received `{keys}`')
    ordered_responses = [resp.get(key, None) for key in keys]
    return ordered_responses if len(ordered_responses) > 1 else ordered_responses[0]
